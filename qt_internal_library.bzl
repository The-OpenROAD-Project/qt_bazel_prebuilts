"""Helpers for building QT framework libraries."""

load("//:qt_tools.bzl", "moc_gen")

def qt_internal_library(
        name = "",
        srcs = [],
        tags = [],
        platform_srcs = [],
        moc_hdrs = [],
        moc_opts = [],
        rcc_srcs = [],
        resource_srcs = [],
        uic_srcs = [],
        deps = [],
        defines = [],
        copts = [],
        linkopts = [],
        linkstatic = False,
        includes = [],
        compatible_with = [],
        qmlcachegen_options = [],
        qmlcachegen_resources = [],
        qmlcachegen_qml_loader_file_list = None,
        qmlcachegen_resource_paths = [],
        hdrs = [],
        alwayslink = 0,
        visibility = [],
        additional_linker_inputs = [],
        local_defines = [],
        outdir_suffix = ""):
    """Rule to build a QT framework library.

    qt_internal_library generates the cc_library rule to build an internal
    library by running moc over the specified headers and sources.

    These rules should be created by looking at the corresponding Makefiles
    generated by qmake after running configure. qmake runs moc and uic over the
    appropriate files (determined by grepping for the Q_OBJECT macro) and
    determines dependencies by grepping for #include statements; its
    determinations should be used in these rules.

    In particular: 1. moc_hdrs should be populated from the
    compiler_moc_header_make_all target in the Makefile.  2. moc_srcs should be
    populated from the compiler_moc_source_make_all target in the Makefile.  3.
    srcs should be populated from the SOURCES var in the Makefile.

    We can't just merge moc_srcs and srcs because certain files need to be moc'd,
    but should not be built because they are #include'd into other cpp files.
    That's why moc outputs need to be explicitly included in srcs.

    Args:
      name: name of the target library.
      srcs: all source files; passed to cc_library.
      tags: passed to cc_library.
      platform_srcs: platform-specific source files; passed to cc_library without inspection.
      moc_hdrs: list of header files to pass through moc tool.
      moc_opts: extra flags passed to moc tool.
      rcc_srcs: list of .qrc files to pass through rcc tool.
      resource_srcs: list of files that will be added in some .qrc file.
      uic_srcs: list of .ui files to pass through uic tool.
      deps: passed to cc_library
      defines: passed to cc_library.
      copts: passed to cc_library.
      linkopts: passed to cc_library.
      linkstatic: passed to cc_library.
      includes: passed to cc_library.
      compatible_with: passed to cc_library.
      qmlcachegen_options: options to qmlcachegen. These values are defined in the build.make file.
      qmlcachegen_resources: arguments to qmlcachegen --resource. These values are defined in the build.make file.
      qmlcachegen_qml_loader_file_list: arguments to qmlcacheghen --resource-name. The value is defined in the build.make file.
      qmlcachegen_resource_paths: arguments to qmlcachegen --resource-path, each should start with
                                  /qt-project.org/imports/.
                                  These are not real paths, if you want to change it, you may need
                                  to change the content in the 'qmlcachegen_qml_loader_file_list'.
                                  These values are defined in the build.make file.
      hdrs: all header files; passed to cc_library.
      alwayslink: passed to cc_library.
      visibility: passed to cc_library.
      additional_linker_inputs: passed to cc_library.
      local_defines: passed to cc_library.
      outdir_suffix: Optional suffix for internal rules and generated files.
    """

    # We'll try to figure out what the first directory is by looking at the
    # first moc_hdr we find. If we can't find one, we'll just make something up
    # based on the source files that begins with qt.
    for hdr in hdrs:
        if "bootstrap" in hdr:
            print(hdr)
    generated_out_dir = None
    if srcs and type(srcs) == type([]):
        for src in srcs:
            if ".moc" in src:
                generated_out_dir = src[:src.find(".moc")]
                break

        # That failed, if it's a plugin, try to guess based on where the
        # plugin's main file is.
        if not generated_out_dir:
            for src in srcs:
                if "plugins" in src and "main" in src[src.rfind("/"):]:
                    generated_out_dir = src[:src.rfind("main")]

    if not generated_out_dir:
        for src in srcs:
            first_dir = src[:src.find("/")]
            if first_dir.startswith("qtbase") and first_dir.endswith("6.9.1"):
                generated_out_dir = "%s/src/%s/" % (first_dir, name)

    if not generated_out_dir:
        # Ehh, just use something.
        fail("%s does not look to be a qt library" % name)

    moc_out_dir = generated_out_dir + ".moc/" + outdir_suffix
    rcc_out_dir = generated_out_dir + ".rcc/" + outdir_suffix
    uic_out_dir = generated_out_dir + ".uic/" + outdir_suffix
    qmlcachegen_out_dir = generated_out_dir + ".qmlcache/" + outdir_suffix

    moc_genrules = []
    moc_files = []
    for src in moc_hdrs:
        rulename = "MOC_" + outdir_suffix.replace("/", "_") + "_" + src.replace("/", "_").replace(":", "_")

        last_slash = src.rindex("/")
        filename = src[last_slash + 1:]

        if filename[-1:] == "h":
            dest = moc_out_dir + "moc_" + filename[:-2] + ".cpp"
        elif filename[-3:] == "cpp":
            dest = moc_out_dir + filename[:-4] + ".moc"
            # The modified file will just have the same name with a different extension
            # temp = src[:last_slash] + outdir_suffix + filename
            # temp = temp.replace(".cpp", ".cc")
            # native.genrule(
            #     name = "SED" + rulename,
            #     srcs = [src],
            #     outs = [temp],
            #     cmd = "sed '/# *include/s/.moc\\([\">]\\)/.moc\\1/g' $< > $@",
            #     compatible_with = compatible_with,
            # )
            # srcs.remove(src)
            # srcs.append(temp)

        else:
            fail("Unsupported extension for %s" % src)

        moc_genrules += [{
            "name": rulename,
            "source": src,
            "output": dest,
        }]

        moc_files.append(dest)

    # Make a dummy library that lets us easily pass defines/copts/includes
    # along with the deps to the moc rule.
    internal_deps_lib_name = name + "_internal_deps"
    native.cc_library(
        name = internal_deps_lib_name,
        compatible_with = compatible_with,
        copts = copts,
        defines = defines + local_defines,
        includes = includes,
        textual_hdrs = hdrs,
    )

    for moc_genrule in moc_genrules:
        moc_gen(
            name = moc_genrule["name"],
            src = moc_genrule["source"],
            out = moc_genrule["output"],
            copts = copts,
            moc_opts = moc_opts,
            deps = deps + [":" + internal_deps_lib_name],
            compatible_with = compatible_with,
            resource_srcs = hdrs + resource_srcs,
            rewrite_includes = False,
            show_warnings = True,
            transitive_deps = True,
        )

    # Run rcc on any .qrc files
    alwayslink_srcs = []
    for src in rcc_srcs:
        rulename = "RCC_" + outdir_suffix.replace("/", "_") + "_" + src.replace("/", "_").replace(":", "_")

        last_slash = src.rindex("/")
        filename = src[last_slash + 1:]
        qrc_name = filename[:filename.rfind(".")]
        dest = rcc_out_dir + "qrc_" + qrc_name + ".cpp"

        native.genrule(
            name = rulename,
            srcs = [src] + resource_srcs,
            outs = [dest],
            tools = [":rcc"],
            # By default, 'rcc' encodes timestamp of the source, which
            # is meaningless on Forge and leads to non-deterministic builds.
            # Override the timestamp with 1ms since epoch (timestamp can't be 0).
            cmd = "QT_RCC_SOURCE_DATE_OVERRIDE=1 " +
                  "$(location :rcc) --name %s $(execpath %s) -o $@" % (qrc_name, src),
            compatible_with = compatible_with,
        )
        alwayslink_srcs.append(dest)

    uic_files = []
    for src in uic_srcs:
        rulename = "UIC_" + outdir_suffix.replace("/", "_") + "_" + src.replace("/", "_").replace(":", "_")

        last_slash = src.rindex("/")
        filename = src[last_slash + 1:]
        ui_name = filename[:filename.rfind(".")]
        dest = uic_out_dir + "ui_" + ui_name + ".h"

        native.genrule(
            name = rulename,
            srcs = [src],
            outs = [dest],
            tools = [":uic"],
            cmd = "$(location :uic) $< -o $@",
            compatible_with = compatible_with,
        )
        uic_files.append(dest)

    # If we were given qmlcachegen_qml_loader_file_list, generate the qmlcache code.
    if qmlcachegen_qml_loader_file_list:
        dest = qmlcachegen_out_dir + "qmlcache_loader.cpp"
        last_slash = qmlcachegen_qml_loader_file_list.rindex("/")
        resource_name = qmlcachegen_qml_loader_file_list[last_slash + 1:].split("_")[0]
        resource_name = "qmlcache_" + resource_name
        cmd = "$(location :qmlcachegen) --resource-name %s -o $@ @$<" % (
            resource_name
        )

        native.genrule(
            name = name + "_qmlcachegen_loader",
            srcs = [qmlcachegen_qml_loader_file_list],
            outs = [dest],
            tools = [":qmlcachegen"] + qmlcachegen_resources,
            cmd = cmd,
            compatible_with = compatible_with,
        )
        alwayslink_srcs.append(dest)

    # Build the cache for each of the qml files listed.
    qmlcachegen_common_option = ""
    for option in qmlcachegen_options:
        qmlcachegen_common_option += " %s" % option
    for resource in qmlcachegen_resources:
        qmlcachegen_common_option += " --resource $(location %s)" % resource
    PATH_PREFIX = "/qt-project.org/imports/"
    for path in qmlcachegen_resource_paths:
        if not path.startswith(PATH_PREFIX):
            continue
        rulename = "QMLCACHEGEN_" + outdir_suffix.replace("/", "_") + "_" + path.replace("/", "_").replace(":", "_")
        last_slash = path.rindex("/")
        filename = path[len(PATH_PREFIX):]
        filename = filename[filename.find("/") + 1:]
        dest = qmlcachegen_out_dir + filename.replace(".", "_") + ".cpp"
        qmlcachegen_option = (" --resource-path %s " % path) + qmlcachegen_common_option
        cmd = "$(location :qmlcachegen)%s --bare -o $@ $<" % qmlcachegen_option
        native.genrule(
            name = rulename,
            srcs = [generated_out_dir + filename],
            outs = [dest],
            tools = [":qmlcachegen"] + qmlcachegen_resources,
            cmd = cmd,
            compatible_with = compatible_with,
        )
        alwayslink_srcs.append(dest)
    alwayslink_deps = []
    if alwayslink_srcs:
        alwayslink_name = "_" + name + "_alwayslink"
        alwayslink_deps = [":" + alwayslink_name]
        native.cc_library(
            name = alwayslink_name,
            alwayslink = 1,
            compatible_with = compatible_with,
            copts = copts,
            deps = deps,
            includes = includes,
            linkopts = linkopts,
            linkstatic = linkstatic,
            additional_linker_inputs = additional_linker_inputs,
            srcs = alwayslink_srcs,
            tags = tags,
        )

    native.cc_library(
        name = name,
        srcs = srcs + platform_srcs,
        tags = tags,
        deps = deps + alwayslink_deps,
        defines = defines,
        copts = copts,
        linkopts = linkopts,
        linkstatic = linkstatic,
        includes = includes + [moc_out_dir, uic_out_dir],
        hdrs = hdrs,
        textual_hdrs = moc_files + uic_files,
        compatible_with = compatible_with,
        visibility = visibility,
        alwayslink = alwayslink,
        additional_linker_inputs = additional_linker_inputs,
        local_defines = local_defines,
    )

def qt_static_plugin(
        name,
        plugin_class_name,
        hdrs = [],
        compatible_with = [],
        **kwargs):
    """Helper function that generates an extra cc file to instantiate the plugin.

    Args:
      name: passed to qt_internal_library.
      plugin_class_name: The C++ class that will be passed to Q_IMPORT_PLUGIN.
      hdrs: passed to qt_internal_library.
      compatible_with: passed to qt_internal_library.
      **kwargs: passed to qt_internal_library.
    """
    qt_internal_library(
        name = name + "_impl",
        hdrs = hdrs,
        compatible_with = compatible_with,
        **kwargs
    )
    native.genrule(
        name = name + "_source_gen",
        outs = [name + ".cc"],
        compatible_with = compatible_with,
        cmd = "echo '#include <QtPlugin>\nQ_IMPORT_PLUGIN(%s);' > $@" % plugin_class_name,
    )
    native.cc_library(
        name = name,
        compatible_with = compatible_with,
        copts = ["-DQT_STATICPLUGIN"],
        deps = [
            ":" + name + "_impl",
            "//qt_source:core",
        ],
        hdrs = hdrs,
        srcs = [name + ".cc"],
        visibility = ["//visibility:public"],
        alwayslink = 1,
    )

def qt_cc_versionless_headers(qt_version, compatible_with = []):
    """Generate a copy of the qt headers that can be reached by including third_party/qt/Qt*.

    These are needed to emulate the cc_inc_library functionality for qt libs. Since we have multiple
    targets that all need to provide the Qt headers, we need a single copy of
    the duplicates so the layering check does not get confused. This rule
    should only be invoked once in the BUILD file, and will generate targets
    used by qt_cc_inc_library.

    Args:
      qt_version: decimal separated string containing the qt version.
      compatible_with: passed to cc_library.
    """
    name = "_" + qt_version.replace(".", "_")
    prefix = "includes/{}".format(name)
    cmd = "mkdir --parents \"$(RULEDIR)/{}\"".format(prefix)
    includes = []
    outs = []
    srcs = []

    # Loop through all the extracted folders for the given qt version.
    roots_with_include = native.glob(
        ["*{}/include".format(qt_version.replace(".", "_"))],
        exclude_directories = 0,
    ) + native.glob(
        ["*{}/build/include".format(qt_version.replace(".", "_"))],
        exclude_directories = 0,
    )
    hdrs = []
    for root_with_include in roots_with_include:
        include_dir = "/build/include" if "build" in root_with_include else "/include"
        root = root_with_include[:root_with_include.rfind(include_dir)]

        # Copy over the entire contents of the 'include' directory, but put it so
        # that after we add an include to it, it lives in third_party/qt/*
        module_hdrs = native.glob([root + include_dir + "/**/*"])
        hdrs += module_hdrs
        srcs += module_hdrs
        outs += ["{}/{}/third_party/qt/qt6/{}".format(
            prefix,
            root,
            hdr.replace(root + include_dir + "/", ""),
        ) for hdr in module_hdrs]
        cmd += "; mkdir -p \"$(RULEDIR)/{}/{}/third_party/qt/qt6\"".format(prefix, root)
        cmd += "; cp -r \"third_party/qt/qt6/{}{}\"/* \"$(RULEDIR)/{}/{}/third_party/qt/qt6\"".format(
            root,
            include_dir,
            prefix,
            root,
        )

        includes += [
            "includes/{}/{}".format(name, root),
            "includes/{}/{}/third_party/qt/qt6".format(name, root),
        ]

        # TODO(thorntonc): This snippet may be handy when we get rid of the
        # :qt_headers dep in qt_cc_inc_library.
        #
        # # Add an individual include for each of the modules in this root.
        # for module in native.glob([root + "/include/*"], exclude_directories = 0):
        #     module_name = module[module.rfind("/") + 1:]
        #     # Stuff in QtANGLE screws up the gl headers, so don't add the shortened path for that.
        #     if module_name in ["QtANGLE"]:
        #         continue
        #     includes += ["includes/{}/{}/third_party/qt/{}".format(name, root, module_name)]

        # Now grab all the .h files in the src directory. We'll put it in the
        # third_party directory directly (not third_party/qt) because many of
        # these headers have relative includes that assume the existence of the
        # 'include' directory on the path. We'll try to minimize the size of
        # the cmd by figuring out what directories have .h files in them, and
        # just doing a cp *.h inside them.
        module_src_hdrs = native.glob([root + "/src/**/*.h"] + [root + "/build/src/**/*.h"])
        hdrs += module_src_hdrs

        # Starlark does't have sets yet..., so meh, hopefully not too slow.
        module_src_dirs = []
        for module_src_hdr in module_src_hdrs:
            module_src_dir = module_src_hdr[:module_src_hdr.rfind("/")].replace(root, "").strip("/")
            srcs.append(module_src_hdr)
            outs.append("{}/{}/third_party/{}/{}".format(
                prefix,
                root,
                module_src_dir,
                module_src_hdr[module_src_hdr.rfind("/") + 1:],
            ))
            if module_src_dir not in module_src_dirs:
                module_src_dirs.append(module_src_dir)

        for module_src_dir in module_src_dirs:
            cmd += "; mkdir --parents \"$(RULEDIR)/{}/{}/third_party/{}\"".format(
                prefix,
                root,
                module_src_dir,
            )
            cmd += "; cp \"third_party/qt/qt6/{}/{}/\"*.h \"$(RULEDIR)/{}/{}/third_party/{}\"".format(
                root,
                module_src_dir,
                prefix,
                root,
                module_src_dir,
            )

    # Actually perform the copy.
    native.genrule(
        name = name + "_inc",
        srcs = srcs,
        outs = outs,
        cmd = cmd,
        compatible_with = compatible_with,
        visibility = ["//visibility:private"],
    )

    native.filegroup(
        name = name + "_hdrs",
        srcs = hdrs,
        compatible_with = compatible_with,
    )

    # Make a no-dep cc_library that we'll use to pick up the includes when we
    # get around to making a qt_cc_inc_library.
    native.cc_library(
        name = name,
        hdrs = [":" + name + "_inc"] + hdrs,
        includes = includes,
        compatible_with = compatible_with,
        visibility = ["//visibility:private"],
    )

def qt_cc_inc_library(name, qt_version, deps = [], compatible_with = [], linkopts = []):
    """A public qt api library with headers that can be reached by including qt_source/qt.

    Combines the given deps with the versionless qt headers.

    Args:
      name: passed to cc_library.
      qt_version: decimal separated string containing the qt version.
      compatible_with: passed to cc_library.
      deps: passed to cc_library.
      compatible_with: passed to cc_library.
      linkopts: passed to cc_library.
    """
    qt_version_underscore = qt_version.replace(".", "_")
    native.cc_library(
        name = name,
        hdrs = [":_" + qt_version_underscore + "_inc", ":_" + qt_version_underscore + "_hdrs"],
        deps = deps + [":_" + qt_version_underscore],
        compatible_with = compatible_with,
        linkopts = linkopts,
        # instruct go/build-cleaner to pretend this target does not define main()
        # so that it can be removed if unused.
        tags = ["cc_main=ignore"],
    )